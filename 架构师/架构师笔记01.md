# 架构师笔记

## 单体应用的缺点

* 系统耦合性高
* 技术选型单一
* 开发效率越来越低效

## 如何破局

### 数据库存储拆分
* 垂直方向拆分 按照业务进行数据库分离 

	会员数据库、商品数据库、交易数据库
	
* 水平方向拆分 当数据量达到一定的量级以后，需要进行分表

	会员表1、会员表2
	
### 架构拆分

* 垂直方向拆分  按照业务维度进行拆分 

	会员服务、商品服务、交易服务
* 水平方向拆分  按照功能维度进行拆分

	网关层、业务逻辑层、数据访问层
	
## 水平分层架构设计实践

* 网关层
* 业务逻辑层
* 数据访问层
* 数据存储层

                      
app -- nginx -- gateway -- 业务逻辑层 -- 数据访问层 -- mysql database

### 分层设计原则

* 展示服务 同 网关服务 分离
* 网关服务 同 逻辑服务 分离
* 逻辑服务 同 数据服务 分离

### 网关层的功能
* 请求鉴权
* 数据完整性检查
  数据包定长Header + 变长Body
  Header包括用户UID、SessionID、CMD、Bodylen(body长度) 
 
* 协议转换
  JSON -> HashMap(String, Object)
  将HTTP协议转为TCP
  将传输协议转换为Protobuf
* 路由转发
  根据CMD转发到不同业务逻辑层
* 服务治理
  限流、降级、熔断等
  
### 网关技术选型
对比维度 | Zuul |  Spring Cloud GateWay | Nginx | Kong | Tyk | Node.js | 自研
------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------
成熟度 | 高 | 低 | 高 | 高 | 高 | 高 | 低
使用成本 | 低 | 较低 | 高 | 较低 | 较低 | 较低 | 低
IO模型 | BIO | Netty | epoll | epoll | AIO | AIO | Netty
技术生态 | Netflix | Spring Cloud | Nginx社区 | OpenRestry | Go社区 | Node.js社区 | 公司内部
适用场景 | 网关 | 网关 | 负载均衡 | 网关 | 网关 | 网关 | 网关

### 业务逻辑层功能

* 业务逻辑处理

### 数据访问层功能
* CRUD 业务增删改查接口
* ORM 
* Sharding 分库分表
* 屏蔽底层存储差异性

### 数据存储演进
* RDBMS 单机关系型数据库 Mydql、Oracle 海量存储成为瓶颈
* NoSQL Mongodb、Hive  解决了海量存储问题，但是没有解决ACID
* NewSQL TiDB  兼顾分布式海量存储以及ACID事务

### 同步架构 or 异步架构

* 同步架构  虽然我们做了水平和垂直分层，但是我们的系统仍然是一个同步架构，从APP发起请求<-->网关<-->业务逻辑层<-->数据访问层<-->数据存储层
* 异步架构 
  在上下游分层之间加入MQ消息队列，改造成异步架构
  
  
  目的： 提升吞吐量
  
  手段： MQ消息队列
  
  适用场景： 
  * 请求类型 一般读请求是同步的，不能使用MQ。大部分的写请求可以使用MQ，数据一致性要求强的场景不适用MQ（读写一致性,例如充值）    
  * 业务类型 要根据具体的场景分析，例如发朋友圈，消息写入MQ后提示成功，但是信息并没有落库，而是利用本地缓存欺骗发布人，等待下次打开的时候队列数据已经落库

### 层次划分颗粒度

* 过多
	* 请求路径变长
	* 平均响应延迟变大
	* 定位问题变复杂化
	* 运维成本增加
* 过少
	* 变成单体
* 适中
	* 同步架构（四层）
		* 网关层
		* 业务逻辑层
		* 数据访问层
		* 数据存储层
	* 异步架构（五层）
		* 网关层
		* 异步消息队列层
		* 业务逻辑层
		* 数据访问层
		* 数据存储层 	

	