# 架构师笔记

## 单体应用

缺点：

* 系统耦合性高
* 技术选型单一
* 开发效率越来越低效

### 如何破局

#### 存储拆分
* 垂直方向拆分 按照业务进行数据库分离 

	会员数据库、商品数据库、交易数据库
	
* 水平方向拆分 当数据量达到一定的量级以后，需要进行分表

	会员表1、会员表2
	
#### 架构拆分

* 垂直方向拆分  按照业务维度进行拆分 

	会员服务、商品服务、交易服务
* 水平方向拆分  按照功能维度进行拆分

	网关层、业务逻辑层、数据访问层
	
## 水平分层架构设计

* 网关层
* 业务逻辑层
* 数据访问层
* 数据存储层

                      
app -- nginx -- gateway -- 业务逻辑层 -- 数据访问层 -- mysql database

### 分层设计原则

* 展示服务 同 网关服务 分离
* 网关服务 同 逻辑服务 分离
* 逻辑服务 同 数据服务 分离

### 网关层的功能
* 请求鉴权
* 数据完整性检查
  数据包定长Header + 变长Body
  Header包括用户UID、SessionID、CMD、Bodylen(body长度) 
 
* 协议转换
  JSON -> HashMap(String, Object)
  将HTTP协议转为TCP
  将传输协议转换为Protobuf
* 路由转发
  根据CMD转发到不同业务逻辑层
* 服务治理
  限流、降级、熔断等
  
### 网关技术选型
对比维度 | Zuul |  Spring Cloud GateWay | Nginx | Kong | Tyk | Node.js | 自研
------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------
成熟度 | 高 | 低 | 高 | 高 | 高 | 高 | 低
使用成本 | 低 | 较低 | 高 | 较低 | 较低 | 较低 | 低
IO模型 | BIO | Netty | epoll | epoll | AIO | AIO | Netty
技术生态 | Netflix | Spring Cloud | Nginx社区 | OpenRestry | Go社区 | Node.js社区 | 公司内部
适用场景 | 网关 | 网关 | 负载均衡 | 网关 | 网关 | 网关 | 网关

### 业务逻辑层功能

* 业务逻辑处理

### 数据访问层功能
* CRUD 业务增删改查接口
* ORM 
* Sharding 分库分表
* 屏蔽底层存储差异性

### 数据存储演进
* RDBMS 单机关系型数据库 Mydql、Oracle 海量存储成为瓶颈
* NoSQL Mongodb、Hive  解决了海量存储问题，但是没有解决ACID
* NewSQL TiDB  兼顾分布式海量存储以及ACID事务

### 同步架构 or 异步架构

* 同步架构  虽然我们做了水平和垂直分层，但是我们的系统仍然是一个同步架构，从APP发起请求<-->网关<-->业务逻辑层<-->数据访问层<-->数据存储层
* 异步架构 
  在上下游分层之间加入MQ消息队列，改造成异步架构
  
  
  目的： 提升吞吐量
  
  手段： MQ消息队列
  
  适用场景： 
  * 请求类型 一般读请求是同步的，不能使用MQ。大部分的写请求可以使用MQ，数据一致性要求强的场景不适用MQ（读写一致性,例如充值）    
  * 业务类型 要根据具体的场景分析，例如发朋友圈，消息写入MQ后提示成功，但是信息并没有落库，而是利用本地缓存欺骗发布人，等待下次打开的时候队列数据已经落库

### 层次划分颗粒度

* 过多
	* 请求路径变长
	* 平均响应延迟变大
	* 定位问题变复杂化
	* 运维成本增加
* 过少
	* 变成单体
* 适中
	* 同步架构（四层）
		* 网关层
		* 业务逻辑层
		* 数据访问层
		* 数据存储层
	* 异步架构（五层）
		* 网关层
		* 异步消息队列层
		* 业务逻辑层
		* 数据访问层
		* 数据存储层
		
### 水平分层架构设计的缺点
* 每层颗粒度过粗
* 动态扩容性差

### 同步水平分层架构全貌
![水平分层架构全貌](https://raw.githubusercontent.com/richenlin/DayDayUp/master/%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%B0%B4%E5%B9%B3%E6%9E%B6%E6%9E%84%E5%85%A8%E8%B2%8C.png)

## 面向服务架构设计

* SOA定义
	* 组件模型
	* 不同功能单元(服务)通过定义的良好接口关联
	* 接口采用重力的方式定义，独立于硬件平台、操作系统和编程语言

* SOA提出
	* 1996年提出
	* 不同认知和理解
	* 2000年逐步落地
		* ESB
		* WebService
		* SOAP
		* ...
* 架构特点 垂直拆分。SOA并不是微服务架构

![SOA架构案例](https://github.com/richenlin/DayDayUp/raw/master/%E6%9E%B6%E6%9E%84%E5%B8%88/SOA%E6%9E%B6%E6%9E%84.jpg)

* SOA缺点
	* 业务垂直方向拆分
		* 每个服务还是单体
	* 严重依赖ESB
		* ESB扩展困难
		* ESB单体问题


## 微服务架构设计

马丁弗勒在2014提出微服务架构模式。

* 一系列微小服务的组合
* 微服务单独运行
* 围绕业务建模能力
* 独立部署
* 支持异构，与具体语言无关

![微服务架构案例](https://github.com/richenlin/DayDayUp/raw/master/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B.jpg)

### 微服务本质

* 从垂直和水平两个维度进行服务拆分
* 业务架构  
* 组织架构  事业群、项目组独立的组织架构更加适合微服务的组织管理

### 适用场景

* 需求层面

	需求变化频繁，需要快速迭代和持续交付
* 性能层面

	微服务会提升系统吞吐量，但是平均响应延时会变大。高频交易、量化交易这种业务不太适合微服务。大部分的互联网场景是适合微服务架构
* 数据一致性层面

	微服务往往会使用分布式事务，满足的是最终一致性。需要强一致性的场景需要适当扩大划分颗粒度
	
### 目的

* 项目快速迭代
* 项目持续交付

### 微服务不是银弹

* 关注服务调用和通信
	
	* 避免循环调用问题
	* 避免同层调用问题  

		业务逻辑层之间，数据访问层之间不能相互调用
	
* 服务治理

	需要考虑降级、熔断
	
* 基础设施组件升级困难
	* 影响基础设施团队的交付能力和交付速度

* 多编程语言之间的”集成“
	* 每种语言服务管理和治理需要单独开发，成本太大

### 微服务架构的演进

* 业务团队专注于业务逻辑本身
* 服务治理、通信交给基础设施团队
* 物理解耦业务研发团队和基础设施团队
* 一套基础设施多语言开发
* 基础设施能力从应用程序中下推
* 真正做到快速迭代、持续交付

这就是 Service Mesh 要解决的问题


## 服务网格架构设计

### Service Mesh

* 最早开发linkerd的Buoyant公司提出，并在内部使用
* 2016年9月29日第一次公开使用
* 2017年初，Service Mesh进入国内技术社区视野

定义：

```
服务网格是一个基础设施层，用于处理服务间的通信。云原生应用有着复杂的服务拓扑， 

服务网格负责在这些拓扑中实现请求的可靠传递。

在实践中，服务网格通常实现为一组轻量级网络代理， 它们与应用程序部署在一起，

而对应用程序透明
```