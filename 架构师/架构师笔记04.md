# 架构师笔记04

## 分布式锁设计

* 分布式环境下，锁定全局唯一资源
	* 请求处理串行化
	* 实际表现互斥锁

分布式锁目的：

* 交易订单锁定
	* 防止重复下单
	* 解决业务层幂等问题
* MQ消费幂等性
	* 发送消息重复
	* 消息消费端去重

在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行价格修改操作。状态的修改行为需要做串行处理，避免出现数据错乱

### 基于redis分布式锁

- 唯一线程串行处理
- 实现方式
	* redis setnx(set if not exists) 命令在指定的key不存在时，为key设置指定的值
		* setnx key value exptime 成功返回1，失败返回0

	* 存在问题
		* 锁时间不可控，不可续租期
		* 单点问题
			* 单实例进程一旦死掉，会彻底阻塞业务流程
			* 主从方式，主从数据异步，会存在锁失效问题
	* 官方建议
		* redis本身建议使用redlock算法来保证，但问题是需要至少三个redis主从实例来完成，维护成本相对较高。redlock等同于自己实现简单的一致性协议，细节繁琐，且容易出错

交易场景不适合使用Redis作为分布式锁，因为要求CP。社交场景或其他业务场景适用，因为满足AP。

### 高可用分布式锁设计目标

- 设计目标
	* 强一致性
	* 服务高可用、系统稳健
	* 锁自动续约及其自动释放
	* 代码高度抽象，业务接入简单
	* 可视化监控及管理

高可用分布式锁设计方案：

  | redis |  zookeeper | etcd
------------- | ------------- | ------------- | -------------
一致性算法 | 无 | paxos（ZAB） | raft
CAP | AP | CP | CP/AP
高可用 | 主从 | N+1 可用 | N+1 可用
接口类型 | 客户端 | 客户端 | http/grpc
实现 | setNX | createEphemeral | restful API

* Redis无法保证数据一致性
* ZooKeeper对锁实现使用创建临时接到和watch机制，执行效率、扩展能力、社区活跃度等均低于etcd

推荐选择基于etcd实现

* 简单KV
* 强一致
* 高可用，无单点
* 数据高可靠，持久化
* V3提供grpc接口，只需申请、释放锁，自动续期

### 分布式锁整体方案

- 分布式Client + etcd
	* Client TTL 模式
	
```
ClientA -> etcd -> ("key", "ttl", "value", "uuid")

ClientB -> etcd -> ("key", "ttl", "value", "uuid")

ClientA拿锁成功，ClientB拿锁失败

A服务需要对etcd报错后台心跳线程。比如key的租期为10s，后台心跳线程为3s，心跳线程负责在拿到key之后，没3ms cas唯一凭证uuid

```
![分布式锁](https://tva1.sinaimg.cn/large/007S8ZIlly1gepq187bysj31190jon2b.jpg)

### 分布式锁特殊场景

- 特殊场景一： 分布式锁只是在同一自然时间的互斥锁，本身不解决幂等性问题
	* 接入业务需要完善从获得锁到释放锁中间的数据幂等性问题
- 特殊场景二：锁没有按照预期续租
	* 心跳续租没有成功
	* 马上启动GC，GC时间太长
- 特殊场景三： etcd内部协调发生问题
	* leader节点挂了，选主过程中无法获得锁
	* Raft日志数据同步发送错误或不一致问题
