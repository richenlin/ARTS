# 架构师笔记03

## 服务无状态化设计

### 定义
- 冗余部署的多个模块（进程）完全对等
- 请求提交到冗余不是的任一模块，处理结果完全一样
- 模块不存储业务上下文信息
- 仅根据每次请求携带的数据进行相应的业务逻辑处理

### 网关鉴权无状态化

- 客户端存储session（JWT）
	* session丢失问题。用户清除缓存等等
	* 占用流量问题
- 服务端存储session
	* redis集群存储

### 业务逻辑层无状态化

- 逻辑数据分离
- 数据存储交给数据存储层，业务逻辑层操作的是抽象数据对象
- 状态数据流转不本地传递，而是利用缓存或者MQ来流转

### 数据存储层无状态

- 物理存储的上层抽象，数据的操作（CRUD）跟具体存储介质（什么类型的数据库）抽象分离。常见的ORM都在做这件事情
- 只负责处理数据流转，保持幂等性

## 服务负载均衡设计

### 负载均衡系统

- 硬件
	* F5
	* A10
	* Radware
- 软件
	* LVS 4层
	* Nginx 7层
	* HAProxy 4、7层
- 反向代理 VS 正向代理

一般来说用户感知到的代理是正向代理，例如类VPN的代理
用户无感知的代理为反向代理，例如用户并不会感知到Nginx，认为是直接访问到服务器

- 负载均衡算法

* Random
* RoundRobin
* ConsistentHash

### 广义负载均衡
- 完整的故障处理恢复机制
	* 故障自动发现
	* 故障服务自动移除，服务熔断机制
	* 请求自动重试
	* 服务恢复自动发现
	
## 服务幂等设计

### 定义：

- 请求层面
	* 保障请求重复执行和执行一次结果相同
	* f...f(f(x)) = f(x)   x是参数,f是执行函数/方法
- 业务层面
	* 同一用户不重复下单
	* 商品不超买
	* MQ消费端去重

### 目的：

- 请求重试
- 结果灾难性
	* 转账
	* 交易

### 幂等范围

- 读/写请求层面
	* 读请求对数据一般不会造成改变，因此天然具有幂等性
	* 写请求对数据会造成改变，需要保证幂等
	
- 架构层面
	* 哪些层会对数据造成改变？
		* 反向代理层    不会
		* 网关层       不会
		* 业务逻辑层    不会
		* 数据访问层    会

### 数据访问层幂等性

- CRUD
	- Create / Insert
```
//insert user values(uid, age, sex, ts);

insert user values(58,18,男,20181208);
```
主键分为业务主键和自增主键，在新增的时候业务主键可以保证幂等性，但是自增主键由数据库生成，无法保证幂等性。可以使用唯一索引

还可以使用分布式的ID生成器，Twitter的snowflake

尽量不使用自增主键，而使用有意义的业务主键。既能提升查询效率（单次查询），又能具备一定的业务属性
使用业务数据特征生成hash，来构造业务主键，能够很好的保障幂等性

	- Read / Select
```
select * from user where uid=5; //幂等
```

	- Update
```
update user set age=18 where uid=58; //绝对值修改幂等
update user set age++ where uid=58;  //相对值修改非幂等
```
	- Delete
```
delete from user where uid=58;   //绝对值幂等
delete from user where uid in bottom 10; //相对值非幂等
```
业务场景中应该避免甚至禁止使用相对值的修改、删除操作。先查询，然后转换为绝对值操作。


### 数据访问层幂等性案例

在互联网业务中，相对值修改/删除的业务场景经常会遇到，如果都按照先查询，然后再绝对值修改/删除的思路，系统吞吐量会受限。可以按照单向状态机制来在每一步修改/删除操作的时候作为查询条件，如果涉及多库、多表，还要引入分布式事务。

- 订单生成，待支付 1
- 支付成功，待发货 2
- 发货完成，待收货 3
- 收货完成，待打款 4
- 打款成功 5

上述的单向状态流，在修改订单状态中是不可逆的，在修改数据的数据，需要增加判断条件

```
update order set state = 2 where state =1 and orderno = 001;
```

### 业务层面幂等性
- 冗余不是多个进程
	* 存在并发消费的可能性
	* 并发转换为串行消费

- 本质
	* 分布式锁的方案

当MQ中一个任务被多次放入的时候，使用任务标识作为分布式锁，并且仅处理一次








