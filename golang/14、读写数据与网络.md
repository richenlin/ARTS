## 读写数据

除了 fmt 和 os 包，我们还需要用到 bufio 包来处理缓冲的输入和输出。

### 读取用户的输入

键盘和标准输入 os.Stdin 读取输入，最简单的办法是使用 fmt 包提供的 Scan 和 Sscan 开头的函数。请看以下程序：

```
// 从控制台读取输入:
package main
import "fmt"

var (
   firstName, lastName, s string
   i int
   f float32
   input = "56.12 / 5212 / Go"
   format = "%f / %d / %s"
)

func main() {
   fmt.Println("Please enter your full name: ")
   fmt.Scanln(&firstName, &lastName)
   // fmt.Scanf("%s %s", &firstName, &lastName)
   fmt.Printf("Hi %s %s!\n", firstName, lastName) // Hi Chris Naegels
   fmt.Sscanf(input, format, &f, &i, &s)
   fmt.Println("From the string we read: ", f, i, s)
    // 输出结果: From the string we read: 56.12 5212 Go
}
```

Scanln 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。Scanf 与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。Sscan 和以 Sscan 开头的函数则是从字符串读取，除此之外，与 Scanf 相同。

您也可以使用 bufio 包提供的缓冲读取（buffered reader）来读取数据，正如以下例子所示：

```
package main
import (
    "fmt"
    "bufio"
    "os"
)

var inputReader *bufio.Reader
var input string
var err error

func main() {
    inputReader = bufio.NewReader(os.Stdin)
    fmt.Println("Please enter some input: ")
    input, err = inputReader.ReadString('\n')
    if err == nil {
        fmt.Printf("The input was: %s\n", input)
    }
}
```

inputReader 是一个指向 bufio.Reader 的指针。inputReader := bufio.NewReader(os.Stdin) 这行代码，将会创建一个读取器，并将其与标准输入绑定。

bufio.NewReader() 构造函数的签名为：
```
func NewReader(rd io.Reader) *Reader
```

### 从命令行读取参数

* os 包中有一个 string 类型的切片变量 os.Args，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。

```
// os_args.go
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	who := "Alice "
	if len(os.Args) > 1 {
		who += strings.Join(os.Args[1:], " ")
	}
	fmt.Println("Good Morning", who)
}
```
命令行参数会放置在切片 os.Args[] 中（以空格分隔），从索引1开始（os.Args[0] 放的是程序本身的名字，在本例中是 os_args）。

* flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量。例如，在某些情况下我们希望在命令行给常量一些不一样的值。

```
package main

import (
	"flag" // command line option parser
	"os"
)

var NewLine = flag.Bool("n", false, "print newline") // echo -n flag, of type *bool

const (
	Space   = " "
	Newline = "\n"
)

func main() {
	flag.PrintDefaults()
	flag.Parse() // Scans the arg list and sets up flags
	var s string = ""
	for i := 0; i < flag.NArg(); i++ {
		if i > 0 {
			s += " "
			if *NewLine { // -n is parsed, flag becomes true
				s += Newline
			}
		}
		s += flag.Arg(i)
	}
	os.Stdout.WriteString(s)
}
```
flag.PrintDefaults() 打印 flag 的使用帮助信息，本例中打印的是：-n=false: print newline

flag.Parse() 扫描参数列表（或者常量列表）并设置 flag, flag.Arg(i) 表示第i个参数。Parse() 之后 flag.Arg(i) 全部可用，flag.Arg(0) 就是第一个真实的 flag，而不是像 os.Args(0) 放置程序的名字。

flag.Narg() 返回参数的数量。解析后 flag 或常量就可用了。 flag.Bool() 定义了一个默认值是 false 的 flag：当在命令行出现了第一个参数（这里是 "n"），flag 被设置成 true（NewLine 是 *bool 类型）。flag 被解引用到 *NewLine，所以当值是 true 时将添加一个 Newline（"\n"）。

flag.VisitAll(fn func(*Flag)) 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn。

### 文件读写

#### 读取文件

在 Go 语言中，文件使用指向 os.File 类型的指针来表示的，也叫做文件句柄。

```
package main

import (
    "bufio"
    "fmt"
    "io"
    "os"
)

func main() {
    inputFile, inputError := os.Open("input.dat")
    if inputError != nil {
        fmt.Printf("An error occurred on opening the inputfile\n" +
            "Does the file exist?\n" +
            "Have you got acces to it?\n")
        return // exit the function on error
    }
    defer inputFile.Close()

    inputReader := bufio.NewReader(inputFile)
    for {
        inputString, readerError := inputReader.ReadString('\n')
        fmt.Printf("The input was: %s", inputString)
        if readerError == io.EOF {
            return
        }      
    }
}
```

变量 inputFile 是 *os.File 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 os 包里的 Open 函数来打开一个文件。该函数的参数是文件名，类型为 string。在上面的程序中，我们以只读模式打开 input.dat 文件。


其他类似函数：

* ReadLine()、ReadBytes()
* ioutil.ReadFile() 将整个文件的内容读到一个字符串里。该方法第一个返回值的类型是 []byte，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil
* bufio.Reader 的 Read() ，带缓冲的读取。用于读取二进制文件
* fmt 包提供的以 FScan 开头的一系列函数。按列读取文件中的数据
* compress包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。
* 用buffer读取文件
  ```
    package main

    import (
        "bufio"
        "flag"
        "fmt"
        "io"
        "os"
    )

    func cat(r *bufio.Reader) {
        for {
            buf, err := r.ReadBytes('\n')
            if err == io.EOF {
                break
            }
            fmt.Fprintf(os.Stdout, "%s", buf)
        }
        return
    }

    func main() {
        flag.Parse()
        if flag.NArg() == 0 {
            cat(bufio.NewReader(os.Stdin))
        }
        for i := 0; i < flag.NArg(); i++ {
            f, err := os.Open(flag.Arg(i))
            if err != nil {
                fmt.Fprintf(os.Stderr, "%s:error reading from %s: %s\n", os.Args[0], flag.Arg(i), err.Error())
                continue
            }
            cat(bufio.NewReader(f))
        }
    }
  ```
* 用切片读取文件。切片提供了 Go 中处理 I/O 缓冲的标准方式，下面 cat 函数的第二版中，在一个切片缓冲内使用无限 for 循环（直到文件尾部 EOF）读取文件，并写入到标准输出（os.Stdout）
  ```
    func cat(f *os.File) {
        const NBUF = 512
        var buf [NBUF]byte
        for {
            switch nr, err := f.Read(buf[:]); true {
            case nr < 0:
                fmt.Fprintf(os.Stderr, "cat: error reading: %s\n", err.Error())
                os.Exit(1)
            case nr == 0: // EOF
                return
            case nr > 0:
                if nw, ew := os.Stdout.Write(buf[0:nr]); nw != nr {
                    fmt.Fprintf(os.Stderr, "cat: error writing: %s\n", ew.Error())
                }
            }
        }
    }
  ```


#### 写入文件

bufio 的 Writer。我们以只写模式打开文件 output.dat，如果文件不存在则自动创建：
```
outputFile, outputError := os.OpenFile("output.dat", os.O_WRONLY|os.O_CREATE, 0666)
```

OpenFile 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。

我们通常会用到以下标志：

* os.O_RDONLY：只读
* os.O_WRONLY：只写
* os.O_CREATE：创建：如果指定文件不存在，就创建该文件。
* os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为0。

在读文件的时候，文件的权限是被忽略的，所以在使用 OpenFile 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。

写入器（缓冲区）对象：
```
outputWriter := bufio.NewWriter(outputFile)
```

简单文本写入：
```
fmt.Fprintf(outputFile, "Some test data.\n")
```

#### 文件拷贝

最简单的方式就是使用 io 包：
```
// filecopy.go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	CopyFile("target.txt", "source.txt")
	fmt.Println("Copy done!")
}

func CopyFile(dstName, srcName string) (written int64, err error) {
	src, err := os.Open(srcName)
	if err != nil {
		return
	}
	defer src.Close()

	dst, err := os.Create(dstName)
	if err != nil {
		return
	}
	defer dst.Close()

	return io.Copy(dst, src)
}
```
注意 defer 的使用：当打开dst文件时发生了错误，那么 defer 仍然能够确保 src.Close() 执行。如果不这么做，src文件会一直保持打开状态并占用资源。