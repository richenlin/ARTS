# 运算符

## 算术运算符

常见可用于整数和浮点数的算术运算符有 +、-、* 和 /。

* / 对于整数运算而言，结果依旧为整数，例如：9 / 4 -> 2。
  
* 取余运算符只能作用于整数：9 % 4 -> 1
  
* 整数除以 0 可能导致程序崩溃，将会导致运行时的恐慌状态

* 浮点数除以 0.0 会返回一个无穷尽的结果，使用 +Inf 表示


还有运算赋值的 -=、*=、/=、%=、++、--

```
b += a  // b = b + a

```
注意：

- 递增(++)及递减(--)只能用于后缀如 i++，不支持 ++i;
- 带有 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的


## 逻辑运算符

Go 中拥有以下逻辑运算符：==、!=、<、<=、>、>=、&&、||、！。

它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool。

```
b3:= 10 > 5 // b3 is true
```

在多个表达式中使用 &&、||，是短路求值的。


## 位运算符

* 按位与 &
  
    对应位置上的值经过和运算结果，并将 T（true）替换为 1，将 F（false）替换为 0
    ```
    1 & 1 -> 1
    1 & 0 -> 0
    0 & 1 -> 0
    0 & 0 -> 0
    ```
* 按位或 |
  
    对应位置上的值经过或运算结果，并将 T（true）替换为 1，将 F（false）替换为 0
    ```
    1 | 1 -> 1
    1 | 0 -> 1
    0 | 1 -> 1
    0 | 0 -> 0
    ```
* 按位异或 ^

    对应位置上的值根据以下规则组合：
    ```
    1 ^ 1 -> 0
    1 ^ 0 -> 1
    0 ^ 1 -> 1
    0 ^ 0 -> 0
    ```
* 位清除 &^ 
  
    将指定位置上的值设置为 0。

* 位左移 <<

    用法：bitP << n。bitP 的位向左移动 n 位，右侧空白部分使用 0 填充；如果 n 等于 0，结果是 bitP，如果 n 大于 0 则结果 bitP 乘以 2 的 n 次方。例如：
    ```
    1 << 10 // 等于 1 KB
    1 << 20 // 等于 1 MB
    1 << 30 // 等于 1 GB
    ```

* 位右移 >>

    用法：bitP >> n。bitP 的位向右移动 n 位，左侧空白部分使用 0 填充；如果 n 等于 0，结果是 bitP，如果 n 大于 0 则结果 bitP 除以 2 的 n 次方。


位左移与 iota 计数配合可优雅地实现存储单位的常量枚举:
```
type ByteSize float64
const (
    _ = iota // 通过赋值给空白标识符来忽略值
    KB ByteSize = 1<<(10*iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)


type BitFlag int
const (
    Active BitFlag = 1 << iota // 1 << 0 == 1
    Send // 1 << 1 == 2
    Receive // 1 << 2 == 4
)

flag := Active | Send // == 3

```
    
## 运算符优先级

优先级由高到低：
```
优先级     运算符
 7      ^ !
 6      * / % << >> & &^
 5      + - | ^
 4      == != < <= >= >
 3      <-
 2      &&
 1      ||
```

可以通过使用括号来临时提升某个表达式的整体运算优先级

